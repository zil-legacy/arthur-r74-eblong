<FLAGS-AND-DEFAULTS (("P-ZORK0" %<>)("ONE-BYTE-PARTS-OF-SPEECH" %<>)(
"WORD-FLAGS-IN-TABLE" T)("IN-ZILCH" T)("P-APOSTROPHE-BREAKS-WORDS" T)(
"P-BE-VERB" T)) (("YES?" "DEFS" #WORD *22460577521*) ("TOO-MANY-NOUNS" "DEFS" #
WORD *20756761267*) ("WHICH-PRINT" "DEFS2" #WORD *16142725767*) (
"CANT-FIND-OBJECT" "DEFS2" #WORD *31753377206*) ("DONT-UNDERSTAND" "DEFS2" #
WORD *15500760673*) ("REFRESH" "DEFS" #WORD *12540440267*) ("CANT-USE-MULTIPLE"
"DEFS" #WORD *13352575546*))>

<ZZPACKAGE "PARSER"> 
<RENTRY PRINT-LEXV TELL-CTHE TELL-THE> 
<INCLUDE "BASEDEFS" "PBITDEFS" "PDEFS"> 
<USE "PMEM" "PSTACK" "REDS"> 
<FILE-FLAGS MDL-ZIL? CLEAN-STACK?> 
<BEGIN-SEGMENT 0> 
<DEFAULTS-DEFINED CANT-FIND-OBJECT CANT-USE-MULTIPLE DONT-UNDERSTAND
PRINT-INTQUOTE PRINT-LEXV REFRESH SETUP-ORPHAN SETUP-ORPHAN-NP TOO-MANY-NOUNS
WHICH-LIST? WHICH-PRINT WINNER-SAYS-WHICH? YES?> 
<DEFINE-ROUTINE TOO-MANY-NEW> 
<DEFINE-ROUTINE NAKED-OOPS> 
<DEFINE-ROUTINE CANT-OOPS> 
<DEFINE-ROUTINE CANT-AGAIN> 
<DEFAULT-DEFINITION CANT-USE-MULTIPLE <DEFINE CANT-USE-MULTIPLE (LOSS WD) <SETG
CLOCK-WAIT T> <TELL "[You can't use more than one object at a time with \""> <
PRINT-VOCAB-WORD .WD> <TELL "\"!]" CR>>> 
<DEFINE-ROUTINE MAKE-ROOM-FOR-TOKENS> 
<DEFINE-ROUTINE REPLACE-ONE-TOKEN> 
<DEFAULT-DEFINITION REFRESH <DEFINE V-$REFRESH () <LOWCORE FLAGS <BAND <LOWCORE
FLAGS> <BCOM ,F-REFRESH>>> <CLEAR -1> <INIT-STATUS-LINE> <RTRUE>>> 
<DEFAULT-DEFINITION PRINT-INTQUOTE <ROUTINE PRINT-INTQUOTE>> 
<DEFAULT-DEFINITION PRINT-LEXV <ROUTINE PRINT-LEXV>> 
<DEFINE-ROUTINE COPY-INPUT> 
<COND (<NOT <OR <CHECK-VERSION? XZIP> <CHECK-VERSION? YZIP>>> <DEFINE
COPY-INBUF (SRC DEST "AUX" CNT:FIX) <SET CNT <- <GETB .SRC 0> 1>> <REPEAT () <
PUTB .DEST .CNT <GETB .SRC .CNT>> <COND (<L? <SET CNT <- .CNT 1>> 0> <RETURN>)>
>> <DEFINE COPY-LEXV (SRC DEST "OPT" (MAX:FIX ,LEXV-LENGTH) "AUX" (CTR:FIX 1))
<PUTB .DEST 0 <GETB .SRC 0>> <PUTB .DEST 1 <GETB .SRC 1>> <SET DEST <ZREST .
DEST <* ,P-LEXSTART:FIX 2>>> <SET SRC <ZREST .SRC <* ,P-LEXSTART:FIX 2>>> <
REPEAT () <ZPUT .DEST 0 <ZGET .SRC 0>> <PUTB .DEST 2 <GETB .SRC 2>> <PUTB .DEST
3 <GETB .SRC 3>> <COND (<G? <SET CTR <+ .CTR 1>> .MAX> <RETURN>)> <SET DEST <
ZREST .DEST <* 2 ,P-LEXELEN:FIX>>> <SET SRC <ZREST .SRC <* 2 ,P-LEXELEN:FIX>>>>
>)> 
<END-SEGMENT> 
<BEGIN-SEGMENT 0> 
<ADD-WORD NO.WORD ADJ> 
<DEFINE-ROUTINE BUFFER-PRINT> 
<DEFINE-ROUTINE CAPITALIZE> 
<DEFINE-ROUTINE PRINT-PARSER-FAILURE> 
<DEFINE-ROUTINE NAKED-ADJECTIVE?> 
<DEFINE-ROUTINE CHANGE-AND-TO-THEN?> 
<DEFAULT-DEFINITION DONT-UNDERSTAND <DEFINE DONT-UNDERSTAND () <SETG CLOCK-WAIT
T> <COND (<AND <EQUAL? 1 <GETB ,P-LEXV ,P-LEXWORDS>> <IFFLAG (P-ZORK0 <
WORD-TYPE? <ZGET ,P-LEXV ,P-LEXSTART> ,P-NOUN-CODE ,P-ADJ-CODE>) (T <OR <
COMPARE-WORD-TYPES <WCN <ZGET ,P-LEXV ,P-LEXSTART>> <GET-CLASSIFICATION NOUN>>
<COMPARE-WORD-TYPES <WCN <ZGET ,P-LEXV ,P-LEXSTART>> <GET-CLASSIFICATION ADJ>>>
)>> <MISSING "verb"> <RETURN T>)> <IF-P-ZORK0 <COND (<COUNT-ERRORS 1> <RETURN T
>)>> <TELL "[Sorry, but I don't understand. Please say that another way, or try
something else.]" CR>>> 
<DEFINE-ROUTINE MISSING> 
<DEFAULT-DEFINITION CANT-FIND-OBJECT <DEFINE CANT-FIND-NPP (NPP PART) <REPEAT (
(OBJ <NPP-NOUN-PHRASE .NPP>)) <COND (<EQUAL? <NOUN-PHRASE-OBJ1 .OBJ> <> ,
NOT-HERE-OBJECT> <NP-CANT-SEE <NOUN-PHRASE-NP1 .OBJ> .PART> <RTRUE>) (<AND <SET
NPP <NPP-NEXT .NPP>> <SET OBJ <NPP-NOUN-PHRASE .NPP>>> T) (T <RFALSE>)>>> <
DEFINE CANT-FIND-OBJECT (NP PART "AUX" TMP) <COND (<AND <PMEM-TYPE? .NP NPP> <
CANT-FIND-NPP .NP .PART>> T) (<AND <PMEM-TYPE? .NP NP> <ZERO? <NP-QUANT .NP>>>
<NP-CANT-SEE .NP .PART> T) (T <TELL "[There isn't any"> <COND (T <TELL "thing">
)> <TELL " to "> <COND (<SET TMP <PARSE-VERB ,PARSE-RESULT>> <PRINT-VOCAB-WORD
.TMP> <COND (<NOT <EQUAL? .PART 0 1>> <TELL !\ > <PRINT-VOCAB-WORD .PART>)>) (T
<TELL "do that to">)> <TELL "!]" CR>)>> <DEFINE NP-CANT-SEE ("OPT" (NP <GET-NP>
) (SYN 0) "AUX" TMP (SHAVE <>)) <COND (<SET TMP <NP-NAME .NP>> <TELL "["> <
TELL-CTHE ,WINNER> <THIS-IS-IT ,WINNER> <TELL " "> <COND (<AND <BTST .SYN ,
SEARCH-MUST-HAVE> <NOT <BTST .SYN ,SEARCH-MOBY>>> <SET SHAVE T> <TELL "do"> <
COND (<NOT <EQUAL? ,WINNER ,PLAYER ,ME>> <TELL "es">)> <TELL "n't have">) (T <
TELL "can't see">)> <TELL " "> <COND (<OR <CAPITAL-NOUN? .TMP> <AND <SET TMP <
NP-ADJS .NP>> <ADJS-POSS .TMP>>> <NP-PRINT .NP T>) (T <TELL "any "> <NP-PRINT .
NP>)> <COND (<NOT .SHAVE> <TELL !\ > <COND (<AND <SET TMP <NP-LOC .NP>> <OR <
AND <PMEM-TYPE? .TMP NOUN-PHRASE> <TELL "in">> <AND <PMEM-TYPE? .TMP LOCATION>
<SET TMP <LOCATION-OBJECT .TMP>> <PRINT-VOCAB-WORD <LOCATION-PREP .TMP>>>>> <
TELL " "> <TELL-THE <NOUN-PHRASE-OBJ1 .TMP>> <THIS-IS-IT <NOUN-PHRASE-OBJ1 .TMP
>>) (T <COND (T <TELL "right ">)> <TELL "here">)>)> <TELL ".]" CR>) (T <
MORE-SPECIFIC>)>>> 
<DEFAULT-DEFINITION WINNER-SAYS-WHICH? <ROUTINE WINNER-SAYS-WHICH?>> 
<DEFAULT-DEFINITION WHICH-LIST? <ROUTINE WHICH-LIST?>> 
<DEFAULT-DEFINITION WHICH-PRINT <DEFINE WHICH-PRINT ("OPT" (NP <GET-NP>)) <
REPEAT ((PTR <NP-LEXEND .NP>) (NOUN <NP-NAME .NP>)) <COND (<==? .NOUN <ZGET .
PTR 0>> <SETG P-OFLAG </ <- .PTR ,P-LEXV> 2>> <COPYT ,G-LEXV ,O-LEXV ,
LEXV-LENGTH-BYTES> <COPYT ,G-INBUF ,O-INBUF <+ 1 ,INBUF-LENGTH>> <ZPUT ,
OOPS-TABLE ,O-AGAIN <ZGET ,OOPS-TABLE ,O-START>> <RETURN>) (<G? ,P-LEXV <SET
PTR <- .PTR ,LEXV-ELEMENT-SIZE-BYTES>>> <RFALSE>)>> <PROG ((SR ,ORPHAN-SR) (TMP
<>) (LEN <FIND-RES-COUNT .SR>) (SZ <FIND-RES-SIZE .SR>)) <COND (<AND <NOT <==?
,WINNER ,PLAYER>> <NOT <SET TMP <WINNER-SAYS-WHICH? .NP>>>> <TELL
"\"I don't understand "> <COND (<WHICH-LIST? .NP .SR> <TELL "if">) (T <TELL
"which"> <COND (<T? .NP> <TELL !\ > <NP-PRINT .NP>)>)>) (<EQUAL? .TMP T> <RTRUE
>) (T <TELL "[Which"> <COND (<T? .NP> <TELL !\ > <NP-PRINT .NP>)> <TELL " do">)
> <TELL " you mean"> <COND (<WHICH-LIST? .NP .SR> <COND (<OR .TMP <==? ,WINNER
,PLAYER>> <TELL !\,>)> <REPEAT ((REM .LEN) (VEC <REST-TO-SLOT .SR FIND-RES-OBJ1
>)) <TELL !\ > <TELL-THE <ZGET .VEC 0>> <COND (<==? .REM 2> <COND (<NOT <==? .
LEN 2>> <TELL !\,>)> <TELL " or">) (<G? .REM 2> <TELL !\,>)> <COND (<L? <SET
REM <- .REM 1>> 1> <RETURN>) (<L? <SET SZ <- .SZ 1>> 1> <COND (T <RETURN>)>) (T
<SET VEC <ZREST .VEC 2>>)>>)> <COND (<AND <NOT <==? ,WINNER ,PLAYER>> <NOT .TMP
>> <TELL ".\"" CR>) (T <TELL "?]" CR>)>>>> 
<DEFINE-ROUTINE NP-PRINT> 
<DEFINE-ROUTINE ADJS-PRINT> 
<DEFAULT-DEFINITION TOO-MANY-NOUNS <DEFINE TOO-MANY-NOUNS (WD) <TELL
"[I can't understand that many nouns with "> <COND (<T? .WD> <TELL !\"> <
PRINT-VOCAB-WORD .WD> <TELL !\">) (T <TELL "that verb">)> <TELL ".]" CR>>> 
<DEFINE-ROUTINE INBUF-ADD> 
<DEFINE-ROUTINE INBUF-PRINT> 
<DEFAULT-DEFINITION YES? <CONSTANT YES-INBUF <ITABLE 19 (BYTE LENGTH) 0>> <
CONSTANT YES-LEXV <ITABLE 3 (LEXV) 0 0>> <DEFINE YES? ("OPT" (NO-Q <>) "AUX"
WORD VAL) <COND (<NOT .NO-Q> <TELL !\?>)> <REPEAT () <TELL "|>"> <COND (T <PUTB
,YES-INBUF 1 0>)> <COND (,DEMO-VERSION? <READ-DEMO ,YES-INBUF ,YES-LEXV>) (T <
ZREAD ,YES-INBUF ,YES-LEXV>)> <COND (<AND <NOT <0? <GETB ,YES-LEXV ,P-LEXWORDS>
>> <SET WORD <ZGET ,YES-LEXV ,P-LEXSTART>>> <COND (<COMPARE-WORD-TYPES <
WORD-CLASSIFICATION-NUMBER .WORD> <GET-CLASSIFICATION VERB>> <SET VAL <
WORD-VERB-STUFF .WORD>>) (T <SET VAL <>>)> <COND (<EQUAL? .VAL ,ACT?YES> <SET
VAL T> <RETURN>) (<OR <EQUAL? .VAL ,ACT?NO> <EQUAL? .WORD ,W?N>> <SET VAL <>> <
RETURN>) (<EQUAL? .VAL ,ACT?RESTART> <V-RESTART>) (<EQUAL? .VAL ,ACT?RESTORE> <
V-RESTORE>) (<EQUAL? .VAL ,ACT?QUIT> <V-QUIT>)>)> <TELL
"[Please type YES or NO.]">> .VAL>> 
<DEFAULT-DEFINITION SETUP-ORPHAN <ROUTINE SETUP-ORPHAN>> 
<DEFAULT-DEFINITION SETUP-ORPHAN-NP <ROUTINE SETUP-ORPHAN-NP>> 
<DEFINE-ROUTINE INSERT-ADJS> 
<DEFINE-ROUTINE INSERT-ADJS-WD> 
<END-SEGMENT> 
<ENDPACKAGE> 